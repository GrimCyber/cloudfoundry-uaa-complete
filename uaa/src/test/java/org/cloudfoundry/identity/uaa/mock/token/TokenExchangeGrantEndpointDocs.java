package org.cloudfoundry.identity.uaa.mock.token;

import org.cloudfoundry.identity.uaa.test.JUnitRestDocumentationExtension;
import org.cloudfoundry.identity.uaa.test.TestClient;
import org.cloudfoundry.identity.uaa.zone.IdentityZone;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.restdocs.ManualRestDocumentation;
import org.springframework.restdocs.headers.RequestHeadersSnippet;
import org.springframework.restdocs.payload.FieldDescriptor;
import org.springframework.restdocs.request.ParameterDescriptor;
import org.springframework.restdocs.snippet.Snippet;
import org.springframework.security.web.FilterChainProxy;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import static org.cloudfoundry.identity.uaa.oauth.token.TokenConstants.GRANT_TYPE_TOKEN_EXCHANGE;
import static org.cloudfoundry.identity.uaa.oauth.token.TokenConstants.TOKEN_EXCHANGE_IMPERSONATE_CLIENT_PERMISSION;
import static org.cloudfoundry.identity.uaa.oauth.token.TokenConstants.TOKEN_TYPE_ACCESS;
import static org.cloudfoundry.identity.uaa.oauth.token.TokenConstants.TOKEN_TYPE_ID;
import static org.cloudfoundry.identity.uaa.test.SnippetUtils.fieldWithPath;
import static org.cloudfoundry.identity.uaa.test.SnippetUtils.headerWithName;
import static org.cloudfoundry.identity.uaa.test.SnippetUtils.parameterWithName;
import static org.springframework.restdocs.headers.HeaderDocumentation.requestHeaders;
import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.documentationConfiguration;
import static org.springframework.restdocs.operation.preprocess.Preprocessors.preprocessResponse;
import static org.springframework.restdocs.operation.preprocess.Preprocessors.prettyPrint;
import static org.springframework.restdocs.payload.JsonFieldType.NUMBER;
import static org.springframework.restdocs.payload.JsonFieldType.STRING;
import static org.springframework.restdocs.payload.PayloadDocumentation.responseFields;
import static org.springframework.restdocs.request.RequestDocumentation.formParameters;
import static org.springframework.restdocs.templates.TemplateFormats.markdown;
import static org.springframework.security.config.BeanIds.SPRING_SECURITY_FILTER_CHAIN;

@ExtendWith(JUnitRestDocumentationExtension.class)
class TokenExchangeGrantEndpointDocs extends TokenExchangeMockMvcBase {
    @Qualifier(SPRING_SECURITY_FILTER_CHAIN)
    @Autowired
    FilterChainProxy securityFilterChain;

    FieldDescriptor f_access_token = fieldWithPath("access_token").type(STRING).description("Access token generated by this grant. [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html#name-successful-response)");
    FieldDescriptor f_issued_token_type = fieldWithPath("issued_token_type").type(STRING).description("Will always be " + TOKEN_TYPE_ACCESS + ". [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html#name-successful-response)");
    FieldDescriptor f_id_token = fieldWithPath("id_token").type(STRING).description("An OpenID Connect [ID token](http://openid.net/specs/openid-connect-core-1_0.html#IDToken). This portion of the token response is only returned when clients are configured with the scope `openid`, the `response_type` includes `id_token`, and the user has granted approval to the client for the `openid` scope.");
    FieldDescriptor f_token_type = fieldWithPath("token_type").type(STRING).description("Will always be `bearer`");
    FieldDescriptor f_scope = fieldWithPath("scope").type(STRING).description("List of scopes present in the `scope` claim in the access token");
    FieldDescriptor f_expires_in = fieldWithPath("expires_in").type(NUMBER).description("Number of seconds before this token expires from the time of issuance");
    FieldDescriptor f_jti = fieldWithPath("jti").type(STRING).description("The unique token ID");
    FieldDescriptor f_refresh_token = fieldWithPath("refresh_token").type(STRING).description("Refresh token issued by this grant, if the client has grant type `refresh_token`");

    ParameterDescriptor p_grant_type = parameterWithName("grant_type").type(STRING).required().description("Must be set to `" + GRANT_TYPE_TOKEN_EXCHANGE + "`");
    ParameterDescriptor p_resource = parameterWithName("resource").type(STRING).optional().description("Ignored");
    ParameterDescriptor p_client_id = parameterWithName("client_id").type(STRING).required().description("Required, registed client with " + GRANT_TYPE_TOKEN_EXCHANGE + "grant type");
    ParameterDescriptor p_client_secret = parameterWithName("client_secret").type(STRING).optional().description("The [secret passphrase configured](#change-secret) for the OAuth client. Optional if it is passed as part of the Basic Authorization header or if client_assertion is sent as part of private_key_jwt authentication.");
    ParameterDescriptor p_client_assertion = parameterWithName("client_assertion").type(STRING).optional(null).description("NOT YET SUPPORTED! <small><mark>UAA 76.23.0</mark></small> Client authentication using method [private_key_jwt](https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication). Optional as replacement of methods client_secret_basic or client_secret_post using secrets. The client needs to have a valid [JWT confiuration](#change-client-jwt) for trust to JWT in client_assertion.");
    ParameterDescriptor p_client_assertion_type = parameterWithName("client_assertion_type").type(STRING).optional(null).description("NOT YET SUPPORTED!<small><mark>UAA 76.23.0</mark></small> [RFC 7523](https://tools.ietf.org/html/rfc7523) describes the type. Must be set to `urn:ietf:params:oauth:client-assertion-type:jwt-bearer` if `client_assertion` parameter is present.");
    ParameterDescriptor p_audience = parameterWithName("audience").type(STRING).optional(null).description("Valid client_id used to impersonate/swap the identity of the calling client in the resulting token. [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html#name-request). Note: The calling client must have `"+String.format(TOKEN_EXCHANGE_IMPERSONATE_CLIENT_PERMISSION, "<client_id>")+"` as an an authority (client.authorities). For example `"+String.format(TOKEN_EXCHANGE_IMPERSONATE_CLIENT_PERMISSION, "cf")+"` to be allowed to impersonate the `cf` client.");
    ParameterDescriptor p_subject_token = parameterWithName("subject_token").type(STRING).required().description("Must be a valid JWT token representing the identity to be assumed in the resulting token. [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html#name-request)");
    ParameterDescriptor p_subject_token_type = parameterWithName("subject_token_type").type(STRING).required().description("Must be " + TOKEN_TYPE_ACCESS + " or " + TOKEN_TYPE_ID + ". [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html#name-request)");
    ParameterDescriptor p_requested_token_type = parameterWithName("requested_token_type").type(STRING).optional().description("Must be " + TOKEN_TYPE_ACCESS + ". [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html#name-request)");
    ParameterDescriptor p_actor_token = parameterWithName("actor_token").type(STRING).optional().description("NOT YET SUPPORTED! [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html#name-request)");
    ParameterDescriptor p_actor_token_type = parameterWithName("actor_token_type").type(STRING).optional().description("NOT YET SUPPORTED! [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html#name-request)");
    ParameterDescriptor p_scope = parameterWithName("scope").type(STRING).optional(null).description("Optional parameter to limit the number of scopes in the `scope` claim of the access token");
    ParameterDescriptor p_response_type = parameterWithName("response_type").type(STRING).optional(null).description("May be set to `token` or `token id_token`. The latter produces an access_token and an id_token if the scope `openid` is present and approved");
    ParameterDescriptor p_token_format = parameterWithName("token_format").type(STRING).optional(null).description("May be set to `opaque` to retrieve revocable and non identifiable access token");


    @BeforeEach
    void setUpContext(ManualRestDocumentation manualRestDocumentation) {
        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext)
                .addFilter(securityFilterChain)
                .apply(documentationConfiguration(manualRestDocumentation)
                        .uris().withPort(80)
                        .and()
                        .snippets()
                        .withTemplateFormat(markdown()))
                .build();
        testClient = new TestClient(mockMvc);
    }

    @Test
    void document_token_exchange_grant_using_basic_auth() throws Exception {

        Snippet responseFields = responseFields(
                f_access_token,
                f_issued_token_type,
                f_id_token,
                f_token_type,
                f_scope,
                f_expires_in,
                f_jti,
                f_refresh_token
        );

        Snippet formParameters = formParameters(
                p_grant_type,
                p_resource,
                p_client_id,
                p_audience,
                p_subject_token,
                p_subject_token_type,
                p_requested_token_type,
                p_actor_token,
                p_actor_token_type,
                p_scope,
                p_response_type,
                p_token_format
        );

        RequestHeadersSnippet headers = requestHeaders(
                headerWithName("Authorization")
                        .description("Uses basic authorization with `base64(client_id:client_secret)` of the client performing the grant. Client must have " + GRANT_TYPE_TOKEN_EXCHANGE + " grant type")
                        .optional()
        );

        IdentityZone defaultZone = IdentityZone.getUaa();

        ThreeWayUAASetup multiAuthSetup = getThreeWayUaaSetUp();
        AuthorizationServer thirdParty = multiAuthSetup.thirdPartyIdp();
        AuthorizationServer workerServer = multiAuthSetup.workerServer();

        //use the id_token(hub) to make a token-exchange on foundation-uaa
        String idToken = (String) multiAuthSetup.controlServerTokens().get("id_token");
        String tokenType = TOKEN_TYPE_ID;
        String requestTokenType = TOKEN_TYPE_ACCESS;
        String audience = null;
        String scope = null;

        ResultActions tokenExchangeResult = performTokenExchangeGrantForJWT(
                workerServer.zone().getIdentityZone(),
                idToken,
                tokenType,
                requestTokenType,
                audience,
                scope,
                workerServer.client(),
                ClientAuthType.BASIC,
                "token id_token"
        );

        tokenExchangeResult.andDo(
                document(
                        "{ClassName}/{methodName}",
                        preprocessResponse(prettyPrint()),
                        headers,
                        formParameters,
                        responseFields
                )
        );

    }

    @Test
    void document_token_exchange_grant_using_form_auth() throws Exception {

        Snippet responseFields = responseFields(
                f_access_token,
                f_issued_token_type,
                f_id_token,
                f_token_type,
                f_scope,
                f_expires_in,
                f_jti,
                f_refresh_token
        );

        Snippet formParameters = formParameters(
                p_grant_type,
                p_resource,
                p_client_id,
                p_client_secret,
                p_audience,
                p_subject_token,
                p_subject_token_type,
                p_requested_token_type,
                p_actor_token,
                p_actor_token_type,
                p_scope,
                p_response_type,
                p_token_format
        );

        RequestHeadersSnippet headers = requestHeaders(
        );

        IdentityZone defaultZone = IdentityZone.getUaa();

        ThreeWayUAASetup multiAuthSetup = getThreeWayUaaSetUp();
        AuthorizationServer thirdParty = multiAuthSetup.thirdPartyIdp();
        AuthorizationServer workerServer = multiAuthSetup.workerServer();

        //use the id_token(hub) to make a token-exchange on foundation-uaa
        String idToken = (String) multiAuthSetup.controlServerTokens().get("id_token");
        String tokenType = TOKEN_TYPE_ID;
        String requestTokenType = TOKEN_TYPE_ACCESS;
        String audience = null;
        String scope = null;

        ResultActions tokenExchangeResult = performTokenExchangeGrantForJWT(
                workerServer.zone().getIdentityZone(),
                idToken,
                tokenType,
                requestTokenType,
                audience,
                scope,
                workerServer.client(),
                ClientAuthType.FORM,
                "token id_token"
        );

        tokenExchangeResult.andDo(
                document(
                        "{ClassName}/{methodName}",
                        preprocessResponse(prettyPrint()),
                        headers,
                        formParameters,
                        responseFields
                )
        );

    }

    @Test
    void document_token_exchange_grant_using_client_assertion() throws Exception {

        Snippet responseFields = responseFields(
                f_access_token,
                f_issued_token_type,
                f_id_token,
                f_token_type,
                f_scope,
                f_expires_in,
                f_jti,
                f_refresh_token
        );

        Snippet formParameters = formParameters(
                p_grant_type,
                p_resource,
                p_client_assertion,
                p_client_assertion_type,
                p_audience,
                p_subject_token,
                p_subject_token_type,
                p_requested_token_type,
                p_actor_token,
                p_actor_token_type,
                p_scope,
                p_response_type,
                p_token_format
        );

        RequestHeadersSnippet headers = requestHeaders(
        );

        IdentityZone defaultZone = IdentityZone.getUaa();

        ThreeWayUAASetup multiAuthSetup = getThreeWayUaaSetUp();
        AuthorizationServer thirdParty = multiAuthSetup.thirdPartyIdp();
        AuthorizationServer workerServer = multiAuthSetup.workerServer();

        //use the id_token(hub) to make a token-exchange on foundation-uaa
        String idToken = (String) multiAuthSetup.controlServerTokens().get("id_token");
        String tokenType = TOKEN_TYPE_ID;
        String requestTokenType = TOKEN_TYPE_ACCESS;
        String audience = null;
        String scope = null;

        ResultActions tokenExchangeResult = performTokenExchangeGrantForJWT(
                workerServer.zone().getIdentityZone(),
                idToken,
                tokenType,
                requestTokenType,
                audience,
                scope,
                workerServer.client(),
                ClientAuthType.CLIENT_ASSERTION,
                "token id_token"
        );

        tokenExchangeResult.andDo(
                document(
                        "{ClassName}/{methodName}",
                        preprocessResponse(prettyPrint()),
                        headers,
                        formParameters,
                        responseFields
                )
        );

    }
}
